>`useMemo` 好像也是有存储值的功能，他两有什么区别呢？
- [1. **核心目的不同**](#1-核心目的不同)
- [2. **存储值与触发渲染的机制**](#2-存储值与触发渲染的机制)
  - [**`useRef`**](#useref)
  - [**`useMemo`**](#usememo)
- [3. **典型使用场景**](#3-典型使用场景)
  - [**`useRef` 的适用场景**](#useref-的适用场景)
  - [**`useMemo` 的适用场景**](#usememo-的适用场景)
- [4. **关键区别总结**](#4-关键区别总结)
- [5. **容易混淆的场景**](#5-容易混淆的场景)
  - [误区 1：用 `useMemo` 替代 `useRef` 存储变量](#误区-1用-usememo-替代-useref-存储变量)
  - [误区 2：用 `useRef` 缓存计算结果](#误区-2用-useref-缓存计算结果)
- [6. **总结：一句话区分**](#6-总结一句话区分)

React 中的 `useMemo` 和 `useRef` 虽然都能“存储值”，但它们的核心用途、工作机制和适用场景有本质区别。以下是它们的对比：

---

### 1. **核心目的不同**
| **`useRef`**                                                                      | **`useMemo`**                                                    |
| --------------------------------------------------------------------------------- | ---------------------------------------------------------------- |
| 用于**持久化存储可变值**（如 DOM 引用、定时器 ID 等），且**不触发组件重新渲染**。 | 用于**缓存计算结果**，避免重复执行昂贵的计算逻辑，**优化性能**。 |
| **直接操作数据**：存储的值可以直接修改（通过 `ref.current`）。                    | **依赖计算结果**：返回的值是根据依赖项动态计算的结果。           |

---

### 2. **存储值与触发渲染的机制**
#### **`useRef`**
- **存储方式**：通过 `ref.current` 存储任意值（对象、DOM 节点、函数等）。
- **更新特性**：修改 `ref.current` **不会触发组件重新渲染**。
- **生命周期**：存储的值在组件生命周期内持久化（除非手动修改）。

```jsx
const ref = useRef(initialValue);
ref.current = newValue; // 修改不会触发渲染
```

#### **`useMemo`**
- **存储方式**：缓存一个函数的计算结果，只有当依赖项变化时才会重新计算。
- **更新特性**：依赖项变化时重新计算，**可能导致组件重新渲染**（如果返回值被用于渲染）。
- **生命周期**：每次渲染时检查依赖项，决定是否重新计算。

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

---

### 3. **典型使用场景**
#### **`useRef` 的适用场景**
- 访问或操作 DOM 元素（如聚焦输入框、获取元素尺寸）。
- 存储与渲染无关的变量（如定时器 ID、前一次的状态值）。
- 在副作用（`useEffect`）中保存值，避免闭包陷阱。

```jsx
// 存储定时器 ID（不触发渲染）
const intervalRef = useRef();
useEffect(() => {
  intervalRef.current = setInterval(() => { /* ... */ });
  return () => clearInterval(intervalRef.current);
}, []);
```

#### **`useMemo` 的适用场景**
- 缓存高开销计算（如大数据量的过滤、排序）。
- 避免子组件不必要的重新渲染（配合 `React.memo`）。
- 保证引用类型（如对象、数组）的稳定性，避免副作用重复触发。

```jsx
// 缓存过滤后的列表（依赖项变化时重新计算）
const filteredList = useMemo(() => {
  return bigList.filter(item => item.type === filterType);
}, [bigList, filterType]);
```

---

### 4. **关键区别总结**
| **特性**         | **`useRef`**                      | **`useMemo`**                  |
| ---------------- | --------------------------------- | ------------------------------ |
| **触发渲染**     | 修改 `current` **不触发**重新渲染 | 依赖变化时**可能触发**重新渲染 |
| **存储内容**     | 任意可变值                        | 函数的返回值（计算结果）       |
| **更新条件**     | 手动修改 `current`                | 依赖项变化时自动重新计算       |
| **性能优化目标** | 避免无关渲染                      | 避免重复计算                   |
| **典型用途**     | DOM 操作、跨渲染周期存储变量      | 缓存计算结果、稳定引用类型     |

---

### 5. **容易混淆的场景**
#### 误区 1：用 `useMemo` 替代 `useRef` 存储变量
```jsx
// ❌ 错误：用 useMemo 存储与渲染无关的值
const timerId = useMemo(() => ({ current: null }), []);
timerId.current = setInterval(...);

// ✅ 正确：用 useRef
const timerRef = useRef(null);
timerRef.current = setInterval(...);
```

#### 误区 2：用 `useRef` 缓存计算结果
```jsx
// ❌ 错误：useRef 不会根据依赖项更新值
const ref = useRef();
ref.current = computeValue(a, b); // 需要手动同步依赖项

// ✅ 正确：用 useMemo 自动依赖计算
const memoizedValue = useMemo(() => computeValue(a, b), [a, b]);
```

---

### 6. **总结：一句话区分**
- **`useRef`**：我要存一个值，这个值的修改不需要触发渲染，且要在多次渲染中保持最新。
- **`useMemo`**：我要缓存一个计算结果，只有依赖项变化时才重新计算，避免重复执行耗时操作。